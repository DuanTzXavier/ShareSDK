buildscript {
    repositories {
        maven { url "http://maven.dev.sh.ctripcorp.com:8081/nexus/content/groups/public" }
//        mavenCentral()

    }
    dependencies {
        classpath 'net.sf.proguard:proguard-gradle:5.2.1'
    }
}



import org.apache.tools.ant.taskdefs.condition.Os

import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipInputStream

project.ext {
    BUILD_TOOLS_VERSION = '21.1.2'
    TARGET_SDK_VERSION = 23

    sdk = [:]
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        sdk.aapt = "${rootDir}/aapt_win.exe"
        sdk.dex = "$sdkDir/build-tools/$BUILD_TOOLS_VERSION/dx.bat"
    } else if (Os.isFamily(Os.FAMILY_MAC)) {
        sdk.aapt = "${rootDir}/aapt_mac"
        sdk.dex = "$sdkDir/build-tools/$BUILD_TOOLS_VERSION/dx"
    } else if (Os.isFamily(Os.FAMILY_UNIX)) {
        sdk.aapt = "${rootDir}/aapt_linux"
        sdk.dex = "$sdkDir/build-tools/$BUILD_TOOLS_VERSION/dx"
    }
    sdk.androidJar = "$sdkDir/platforms/android-$TARGET_SDK_VERSION/android.jar"
    if (TARGET_SDK_VERSION >= 23) {
        sdk.apacheJar = "$sdkDir/platforms/android-23/optional/org.apache.http.legacy.jar";
    }
}

//初始化，确保必要目录都存在
task init << {
    new File(rootDir, 'build-inputs').mkdirs()
    new File(rootDir, 'build-outputs').mkdirs()
    new File(rootDir, 'build-outputs/remoteApk').mkdirs()

    buildDir.mkdirs()

    new File(buildDir, 'gen/r').mkdirs()

    new File(buildDir, 'intermediates').mkdirs()

    new File(buildDir, 'intermediates/classes').mkdirs()

    new File(buildDir, 'intermediates/classes-obfuscated').mkdirs()

    new File(buildDir, 'intermediates/res').mkdirs()

    new File(buildDir, 'intermediates/dex').mkdirs()

    //拷贝其他BU的so文件到output中
    new File(rootDir, "/build-outputs/jni/armeabi/").mkdirs()
    new File(rootDir, "/build-outputs/jni/x86/").mkdirs()
	if (project.hasProperty('aarList')) {
		task aarLibPrepare(type: UnZipTask){
			sources = fileTree(new File(rootDir, 'CTRepo/localRepo')).include(aarList.split(","))
			target = "$buildDir/intermediates/explore-aar"
		}
		aarLibPrepare.execute()
	}

}


//清除build产出物
task clean(type: Delete) {
    delete buildDir
    delete "${rootDir}/build-inputs/"
    delete "${rootDir}/build-outputs/remoteApk"
    delete "${rootDir}/build-outputs/${apkName}-mapping.txt"
    delete "${rootDir}/build-outputs/${apkName}.so"
    delete "${rootDir}/build-outputs/jni"
    delete "${rootDir}/build-outputs/lint"
}

task aaptRelease(type: Exec, dependsOn: 'init') {
    def intputBaseAPK = "${rootDir}/build-outputs/Ctrip-base-release.apk"
    def intputBaseRfile = "${rootDir}/CtripMain/build/generated/source/r/release/ctrip/android/view/R.java"
    if (rootProject.hasProperty('bundleVersion')) {
        intputBaseAPK = "${rootDir}/build-inputs/CtripMain-${project.dependencyVersion}-APK.apk"
        intputBaseRfile = "${rootDir}/build-inputs/CtripMain-${project.dependencyVersion}-R.java"
    }

    inputs.file "$sdk.androidJar"
    inputs.file intputBaseAPK
    inputs.file "$projectDir/AndroidManifest.xml"
    inputs.dir "$projectDir/res"
    inputs.dir "$projectDir/assets"

    def inputRfile = ''
    def appPackageName = 'ctrip.android.view'
    def resourceId = ''
    def parentPackageName = ''
    def parseApkXml = (new XmlParser()).parse(new File(rootDir, 'apk_module_config.xml'))
    parseApkXml.Module.each { module ->
        if (module.@packageName == "${packageName}") {
            resourceId = module.@resourceId
            println "find packageName: " + module.@packageName + " ,resourceId:" + resourceId
        }
        if(project.hasProperty('parentModuleName')){
            if(module.@moduleName == "${parentModuleName}"){
                parentPackageName = module.@packageName
            }
        }
    }
    if (project.hasProperty('parentModuleName') && rootProject.hasProperty('TypeModuleSO')) {
        inputRfile = "${rootDir}/build-inputs/${parentModuleName}-${parentDependency}-R.java"
        appPackageName = "${parentPackageName}-" + appPackageName
    } else if (project.hasProperty('parentModuleName')) {
        def parentProject = project(":${parentModuleName}");
        def parentPackagePath = parentProject.packageName.replace('.', '/')
        inputRfile = "${parentProject.buildDir}/gen/r/${parentPackagePath}/R.java"
        appPackageName = "${parentPackageName}-" + appPackageName
    } else {
        inputRfile = intputBaseRfile
    }
    inputs.file inputRfile

    outputs.dir "$buildDir/gen/r"
    outputs.file "$buildDir/intermediates/res/resources.zip"
    outputs.file "$buildDir/intermediates/res/aapt-rules.txt"

    workingDir buildDir
    executable sdk.aapt

    def argv = []
    argv << 'package'   //打包
    argv << "-v"
    argv << '-f' //强制覆盖已有文件
    argv << "-I"
    argv << "$sdk.androidJar"        //添加一个已有的固化jar包
    argv << '-I'
    argv << intputBaseAPK
    if (project.hasProperty('parentModuleName') && rootProject.hasProperty('TypeModuleSO')) {
        argv << '-I'
        argv << "${rootDir}/build-inputs/${parentModuleName}-${parentDependency}-RES.zip"
    } else if (project.hasProperty('parentModuleName')) {
        def parentProject = project(":${parentModuleName}");
        argv << '-I'
        argv << "${parentProject.buildDir}/intermediates/res/resources.zip"
    }
    if (project.hasProperty('aarList')) {
        UnZipTask aarPrepare = task(aarPrepare, type: UnZipTask)
        aarPrepare.sources = fileTree(new File(rootDir, 'CTRepo/localRepo')).include(aarList.split(","))
        aarPrepare.target = "$buildDir/intermediates/explore-aar"
        aarPrepare.execute()
        argv << '--auto-add-overlay'
        def extraPackages = ""
        for (String aarName : aarList.split(",")) {
            def parseManifestXml = new XmlSlurper().parse("$buildDir/intermediates/explore-aar/${aarName}/AndroidManifest.xml")
            println "+++++++++++++++++parseManifestXml.@'package': " + parseManifestXml.@'package'
            extraPackages = extraPackages  + ":" + parseManifestXml.@'package'
            argv << '-M'
            argv << "$buildDir/intermediates/explore-aar/${aarName}/AndroidManifest.xml"
            //指定manifest文件
            argv << '-S'
            argv << "$buildDir/intermediates/explore-aar/${aarName}/res"
            argv << '-A'
            argv << "$buildDir/intermediates/explore-aar/${aarName}/assets"
            //assets目录
        }
        extraPackages = extraPackages.substring(1, extraPackages.length())
        println "+++++++++++++++++--extra-packages : " + extraPackages
        argv << '--extra-packages'
        argv << extraPackages
    }

    argv << '-M'
    argv << "$projectDir/AndroidManifest.xml"    //指定manifest文件
    argv << '-S'
    argv << "$projectDir/res"                    //res目录
    argv << '-A'
    argv << "$projectDir/assets"                 //assets目录
    argv << '-m'        //make package directories under location specified by -J
    argv << '-J'
    argv << "$buildDir/gen/r"         //哪里输出R.java定义
    argv << '-F'
    argv << "$buildDir/intermediates/res/resources.zip"   //指定apk的输出位置
    argv << '-G'        //-G  A file to output proguard options into.
    argv << "$buildDir/intermediates/res/aapt-rules.txt"
    // argv << '--debug-mode'      //manifest的application元素添加android:debuggable="true"
    argv << '--custom-package'      //指定R.java生成的package包名
    argv << "${packageName}"
    argv << '-0'    //指定哪些后缀名不会被压缩
    argv << 'apk'
    argv << '--public-R-path'
    argv << inputRfile
    argv << '--apk-module'
    argv << "$resourceId"
    argv << '--apk-package'
    argv << "${appPackageName}"
    args = argv

}

task compileRelease(type: JavaCompile, dependsOn: 'aaptRelease') {
    def inputBaseJar = "${rootDir}/CtripMain/build/intermediates/transforms/proguard/release/jars/3/1f/main.jar"
    if(rootProject.hasProperty('bundleVersion')){
        inputBaseJar = "${rootDir}/build-inputs/CtripMain-${dependencyVersion}-JAR.jar"
    }

    inputs.file "$sdk.androidJar"
    inputs.files fileTree("${projectDir}/libs").include('*.jar')
    inputs.files fileTree("$projectDir/src").include('**/*.java')
    inputs.files fileTree("$buildDir/gen/r").include('**/*.java')
    inputs.files fileTree("$buildDir/intermediates/explore-aar").include('**/*.jar')

    outputs.dir "$buildDir/intermediates/classes"
    sourceCompatibility = '1.7'
    targetCompatibility = '1.7'

    def inputJarfile = ''
    if (project.hasProperty('parentModuleName') && rootProject.hasProperty('TypeModuleSO')) {
        inputJarfile = "${rootDir}/build-inputs/${parentModuleName}-${parentDependency}-JAR.jar"
        inputs.file "${inputJarfile}"
    } else if (project.hasProperty('parentModuleName')) {
        def parentProject = project(":$parentModuleName");
        inputJarfile = "${parentProject.buildDir}/intermediates/classes-obfuscated/classes-obfuscated.jar"
        inputs.file "${inputJarfile}"
    }
    inputs.file inputBaseJar
    classpath = files(
            "${sdk.androidJar}",
            "${sdk.apacheJar}",
            fileTree("${projectDir}/libs").include('*.jar'),
            inputBaseJar
    )
    if (project.hasProperty('parentModuleName')) {
        classpath.from(inputJarfile)
    }
    if (project.hasProperty('aarList')) {
        classpath.from(fileTree("$buildDir/intermediates/explore-aar").include('**/*.jar'))
    }

    destinationDir = file("$buildDir/intermediates/classes")

    dependencyCacheDir = file("${buildDir}/dependency-cache")

    source = files(fileTree("$projectDir/src").include('**/*.java'),
            fileTree("$buildDir/gen/r").include('**/*.java'))
    options.encoding = 'UTF-8'
}

task copySofileTask(dependsOn: 'compileRelease') {
    String subPath = file("$buildDir").getParent()
    copy {
        from "$subPath/libs/armeabi/"
        into "$rootDir/build-outputs/jni/armeabi/"
    }

    if (project.hasProperty('aarList')) {
        for(String aarDir : aarList.split(",")) {
            copy {
                from "$buildDir/intermediates/explore-aar/$aarDir/jni/armeabi"
                into "$rootDir/build-outputs/jni/armeabi/"
            }
        }
    }

    copy {
        from "$subPath/libs/x86/"
        into "$rootDir/build-outputs/jni/x86/"
    }
}

task obfuscateRelease(type: proguard.gradle.ProGuardTask, dependsOn: 'copySofileTask') {
    def inputBaseJar ="${rootDir}/CtripMain/build/intermediates/transforms/proguard/release/jars/3/1f/main.jar"
    if(rootProject.hasProperty('bundleVersion')){
        inputBaseJar = "${rootDir}/build-inputs/CtripMain-${dependencyVersion}-JAR.jar"
    }

    inputs.file "$rootDir/sub-project-proguard-rules.pro"
    inputs.file "$buildDir/intermediates/res/aapt-rules.txt"
    inputs.dir "$buildDir/intermediates/classes"
    inputs.files fileTree("${projectDir}/libs").include('*.jar')
    inputs.file "${sdk.androidJar}"
    inputs.files fileTree("$buildDir/intermediates/explore-aar").include('**/*.jar')


    def inputFiles = ''
    if (project.hasProperty('parentModuleName') && rootProject.hasProperty('TypeModuleSO')) {
        inputFiles = "${rootDir}/build-inputs/${parentModuleName}-${parentDependency}-JAR.jar"
        inputs.file inputFiles
    } else if (project.hasProperty('parentModuleName')) {
        def parentProject = project(":${parentModuleName}");
        inputFiles = "${parentProject.buildDir}/intermediates/classes-obfuscated/classes-obfuscated.jar"
        inputs.file inputFiles
    }
    inputs.file inputBaseJar

    outputs.file "$buildDir/intermediates/classes-obfuscated/classes-obfuscated.jar"
    outputs.file "${rootDir}/build-outputs/${apkName}-mapping.txt"

    configuration file("$rootDir/sub-project-proguard-rules.pro")
    configuration file("$buildDir/intermediates/res/aapt-rules.txt")
    injars file("$buildDir/intermediates/classes")
    injars fileTree("${projectDir}/libs").include('*.jar')
    injars fileTree("$buildDir/intermediates/explore-aar").include('**/*.jar')

    outjars file("$buildDir/intermediates/classes-obfuscated/classes-obfuscated.jar")
    printmapping file("${rootDir}/build-outputs/${apkName}-mapping.txt")

    libraryjars file("${sdk.androidJar}")

    if (project.hasProperty('parentModuleName')) {
        libraryjars file(inputFiles)
    }
    libraryjars file(inputBaseJar)

}

task dexRelease(type: Exec, dependsOn: 'obfuscateRelease') {
    inputs.file "${buildDir}/intermediates/classes-obfuscated/classes-obfuscated.jar"
    outputs.file "${buildDir}/intermediates/dex/${project.name}_dex.zip"
    workingDir buildDir
    executable sdk.dex

    def argv = []
    argv << '--dex'
    argv << "--output=${buildDir}/intermediates/dex/${project.name}_dex.zip"
    argv << "${buildDir}/intermediates/classes-obfuscated/classes-obfuscated.jar"

    args = argv
}

task bundleRelease(type: Zip, dependsOn: ['obfuscateRelease', 'compileRelease', 'aaptRelease', 'dexRelease']) {
    def remoteLoadPackage = ["ctrip_android_translator"] as String[]
    inputs.file "$buildDir/intermediates/dex/${project.name}_dex.zip"
    inputs.file "$buildDir/intermediates/res/resources.zip"
    println "bundleReleasePackage: " + "${apkName}"
    if (remoteLoadPackage.contains("${apkName}")) {
        println "remoteLoadPackage: " + "${apkName}"
        outputs.file "${rootDir}/build-outputs/remoteApk/${apkName}.so"
        archiveName = "${apkName}.so"
        destinationDir = file("${rootDir}/build-outputs/remoteApk")
    } else {
        outputs.file "${rootDir}/build-outputs/${apkName}.so"
        archiveName = "${apkName}.so"
        destinationDir = file("${rootDir}/build-outputs")
    }
    duplicatesStrategy = 'fail'
    from zipTree("$buildDir/intermediates/dex/${project.name}_dex.zip")
    from zipTree("$buildDir/intermediates/res/resources.zip")
}

class UnZipTask extends DefaultTask {
    @InputFiles
    FileCollection sources

    String target

    @TaskAction
    void concat() {
        String path = target + File.separatorChar
        sources.each { sourceFile->
            ZipFile zipFile = new ZipFile(sourceFile)
            ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(sourceFile))
            ZipEntry zipEntry = null
            while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                String fileName = zipEntry.getName()
                File tmpFile = new File(path + sourceFile.getName() +  File.separatorChar  + fileName)
                if (!tmpFile.getParentFile().exists()) {
                    tmpFile.getParentFile().mkdirs()
                }
                if (zipEntry.isDirectory()) {
                    tmpFile.mkdir()
                    continue
                }
                System.out.println(tmpFile.getName())
                OutputStream os = new FileOutputStream(tmpFile)
                InputStream is = zipFile.getInputStream(zipEntry)
                int len = 0
                while ((len = is.read()) != -1)
                    os.write(len)
                os.close()
                is.close()
            }
            zipInputStream.close();
            File tmpFile = new File(path + sourceFile.getName() +  File.separatorChar  + "assets/.gitignore")
            if (!tmpFile.getParentFile().exists()) {
                tmpFile.getParentFile().mkdirs()
            }
            OutputStream os = new FileOutputStream(tmpFile)
            os.write("/build\n*.iml".bytes)
            os.close()
        }

    }
}

